---
title: "Assignment V: GitHub and the ticketmaster.com API"
subtitle: "Data Science Project Management | Winter Term 2020/21"
author: "Submitted by Franziska Müller (Student ID: 5401673)"
date: "February, 16, 2021"
output: 
  html_document:
  toc: true
---
  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
I hereby assure that my submission is in line with the *Code of Conduct* outlined on the lecture slides. I worked on my own.

## General setup

Before I start the project, I clear my workspace. 
# Note regarding key and maybe working directory

```{r preparation, message = FALSE, warning = FALSE}
# Clear workspace
rm(list = ls())

# Maybe note regarding individual working directory 

# Source private key - insert yout indicidual path to the key
# source("C:/Users/Francesca/Desktop/MA_WiSe 202021/Data Science Project Management/Assignments/key_ticketmaster.R")

key <- "7elxdku9GGG5k8j0Xm8KWdANDgecHMV0"
```

## Exercise 2: Getting to know the API

Rate limit is given by 5 requests per second and max. 5,000 requests per day.


## Exercise 3: Interacting with the API - the basics

*Load the packages needed to interact with APIs using R.*
```{r packages, message = FALSE, warning = FALSE}
# Check if packages have been installed before; if not, install them
if (!require("jsonlite")) install.packages("jsonlite")
if (!require("httr")) install.packages("httr")
if (!require("rlist")) install.packages("rlist")
if (!require("tidyverse")) install.packages("tidyverse")
# if (!require("naniar")) install.packages("naniar")

# Load packages
library(jsonlite)  
library(httr)
library(rlist)
library(tidyverse)
# library(naniar)
```

*Perform a first GET request, that searches for event venues in Germany (countryCode = "DE"). Extract the content from the response object and inspect the resulting list. Describe what you can see.*

```{r first_GET_request}

my_url <- paste0("https://app.ticketmaster.com/discovery/v2/venues.json?apikey=", key)

# Create a function for better reusability
get_content <- function(country, page) {
  resp_obj <- GET(url = my_url, 
                     query = list(countryCode = country,
                                  page = page))
  cont_obj <- resp_obj %>% content()
  return(cont_obj)
}

country <- 'DE'
Ex3_cont_obj <- get_content(country, 0)
# Use page = 0 in order to get the first 20 results

```
The resulting content object is a list with nested structure. It contains the lists named ``r names(Ex3_cont_obj)[1]``, ``r names(Ex3_cont_obj)[2]`` and `` names(Ex3_cont_obj)[3]``. The first one covers different venues and detailed information about a specific venue such as name, type, postal code etc. Interesting here, the lists have different lenghts. Therefore, not every information is given for every venue.
The second one contains links regarding the first, self (actual scraped page), next and last page. Here, it is shown that there are 3465 pages in total with 20 results each. In the last one also information about pages and results is given but just the raw information without the respective url. Again, there are ``r Ex3_cont_obj[["page"]][["totalPages"]]`` pages with ``r Ex3_cont_obj[["page"]][["size"]]`` elements each (in total: ``r Ex3_cont_obj[["page"]][["totalElements"]]`` elements).

*Extract 'name', 'city', 'postalCode', 'adress', 'url', longitude', 'latitude'.*
Will get 20 different venues (size = 20, but note the high amount of pages).

```{r Extracting_specific_elements}
# Create an empty data frame with number of rows = 20
n = 20
df_Ex3 <- tibble(name = character(n),
                 city = character(n),
                 postalCode = character(n),
                 adress = character(n),
                 url = character(n),
                 longitude = character(n),
                 latitude = character(n))

fill_dataframe <- function(cont_obj, df) {
  for (i in 1:n) {
  df[i, 1] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["name"]])  # ith row, first col
  df[i, 2] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["city"]][["name"]])
  df[i, 3] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["postalCode"]])
  df[i, 4] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["address"]][["line1"]])
  df[i, 5] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["url"]])
  
  # Location variable (long/lat)
  if (is.character(cont_obj[["_embedded"]][["venues"]][[i]][["location"]][["longitude"]]) == FALSE) {
    df[i, 6] <- NA
    } else {
      df[i, 6] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["location"]][["longitude"]])
    }
  # Latitude
  if (is.character(cont_obj[["_embedded"]][["venues"]][[i]][["location"]][["latitude"]]) == FALSE) {
    df[i, 7] <- NA
    } else {
      df[i, 7] <- as_tibble(cont_obj[["_embedded"]][["venues"]][[i]][["location"]][["latitude"]])
    }
  }
  return(df)
}

df_Ex3 <- fill_dataframe(Ex3_cont_obj, df_Ex3)  # could also write x <- fill_dataframe(..., df)

# Adapt to numerical type
# Note: double and numeric are "identical": Double describes the type, numeric the mode (implicit the class)
df_Ex3$longitude <- parse_number(df_Ex3$longitude)
df_Ex3$latitude <- parse_number(df_Ex3$latitude)

glimpse(df_Ex3)

# Converting the type to double  ----
# Note: as.double is a generic function, it`s identical to as.numeric
#test <- df_Ex3[, 6:7]
#test$longitude <- parse_number(test$longitude)
#options(digits = 10)  # these options just refer to printing - not to the object itself in the environment
#test$longitude <- as.numeric(test$longitude)
# test[ , 1] <- as.numeric(unlist(test[ , 1]))  # Problem: "Rounding"
#df_Ex3 <- df_Ex3 %>% mutate(longitude = as.numeric(longitude), latitude = as.numeric(latitude))

```

## Exercise 4: Interacting with the API - advanced

*Have a closer look at the element list named ``page``.*
There are ``r Ex3_cont_obj[["page"]][["totalPages"]]`` pages with ``r Ex3_cont_obj[["page"]][["totalElements"]]`` elements in total. 
Note: The loop must be enriched with further statements to get the elements from the last page
Use the parameter ``page`` to access the different pages. 

```{r Ex_4}
# Create empty data frame
m = as.numeric(Ex3_cont_obj[["page"]][["totalElements"]])
df_Ex4 <- tibble(name = character(m),
                 city = character(m),
                 postalCode = character(m),
                 adress = character(m),
                 url = character(m),
                 longitude = character(m),
                 latitude = character(m))

dummy_df <- tibble(name = character(n),
                   city = character(n),
                   postalCode = character(n),
                   adress = character(n),
                   url = character(n),
                   longitude = character(n),
                   latitude = character(n))

# Creating cont Obj
cont_obj_0 <- get_content(country, 0)
cont_obj_1 <- get_content(country, 1)
# Use fill_dataframe fct
test <- fill_dataframe(cont_obj_0, dummy_df)


# Loop 
pages <- 2  # dummy variable for faster testing
# pages <- floor(m/n)  237
# Controll for remainder: m - pages*n 
# pages <- as.numeric(Ex3_cont_obj[["page"]][["totalPages"]])

all_info_one_country <- function(df, dummy_df, country, pages) {
  # Note: erste Seite nicht vergesssen (page = 0)
  for (j in 1:pages) {
  cont_obj <- get_content(country, j)
  df[(20*j - 19):(20*j), ] <- fill_dataframe(cont_obj = cont_obj, df = dummy_df)  # Hier liegt ein Fehler
  # Pause einführen wegen request rate
  Sys.sleep(time = 60/5)
  }
  return(df)
  }

```
jhklsgf
```{r test}
# i = 1
test_df <- tibble(name = character(n),
                 city = character(n),
                 postalCode = character(n),
                 adress = character(n),
                 url = character(n),
                 longitude = character(n),
                 latitude = character(n))
cont_obj_1 <- get_content(country, 1)
# test_df[1:20, ] 
test_df <- fill_dataframe(cont_obj_1, test_df)  # Not working with cont_obj other than cont_obj for page 0

# Inspect the wirtten function in Detail
#i = 1
test_df[1, 1] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["name"]])  # ith row, first col
  test_df[1, 2] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["city"]][["name"]])
  test_df[1, 3] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["postalCode"]])
  test_df[1, 4] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["address"]][["line1"]])
  test_df[1, 5] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["url"]])
  
  # Location variable (long/lat)
  if (is.character(cont_obj_1[["_embedded"]][["venues"]][[1]][["location"]][["longitude"]]) == FALSE) {
    test_df[1, 6] <- NA
    } else {
      test_df[1, 6] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["location"]][["longitude"]])
    }
  # Latitude
  if (is.character(cont_obj_1[["_embedded"]][["venues"]][[1]][["location"]][["latitude"]]) == FALSE) {
    test_df[1, 7] <- NA
    } else {
      test_df[1, 7] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[1]][["location"]][["latitude"]])
    }

# i = 2
#i = 2
  
test_df[2, 1] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[2]][["name"]])  # ith row, first col
  test_df[i, 2] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[i]][["city"]][["name"]])
  test_df[i, 3] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[i]][["postalCode"]])
  test_df[2, 4] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[2]][["address"]][["line1"]])
  test_df[i, 5] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[i]][["url"]])
  
  # Location variable (long/lat)
  if (is.character(cont_obj_1[["_embedded"]][["venues"]][[i]][["location"]][["longitude"]]) == FALSE) {
    test_df[i, 6] <- NA
    } else {
      test_df[i, 6] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[i]][["location"]][["longitude"]])
    }
  # Latitude
  if (is.character(cont_obj_1[["_embedded"]][["venues"]][[i]][["location"]][["latitude"]]) == FALSE) {
    test_df[i, 7] <- NA
    } else {
      test_df[i, 7] <- as_tibble(cont_obj_1[["_embedded"]][["venues"]][[i]][["location"]][["latitude"]])
}
  
# Merge with big df
df_Ex4[1:20, ] <- test_df



```